package gr.aueb.cf.ch10;
/*
* Έστω ένας πίνακας n ακεραίων. Τότε ο maximum sum subarray ο είναι ο συνεχόμενος
υποπίνακας (contiguous subarray - δυνητικά κενό) με το μεγαλύτερο άθροισμα.
Σχεδιάστε έναν γραμμικό αλγόριθμο (με πολυπλοκότητα O(n)) για να επιλύσετε τα
παραπάνω πρόβλημα. Για παράδειγμα, αν έχουμε τον πίνακα {−2, 1, −3, 4, −1, 2, 1,
−5, 4} τότε ο συνεχόμενος υποπίνακας με το μέγιστο άθροισμα είναι ο {4, −1, 2, 1},
του οποίου το άθροισμα είναι 6.
Δώστε μια λύση τριών μερών της ακόλουθης μορφής:
(α) Περιγράψτε (με λόγια και σχήματα) ξεκάθαρα τον αλγόριθμό σας.
(β) Γράψτε τον κώδικα σε Java .
(γ) Δείξτε ότι η πολυπλοκότητα χρόνου είναι O(n)
Hint. Χρησιμοποιήστε δυναμικό προγραμματισμό (βασική αρχή στον δυναμικό
προγραμματισμό είναι όταν υπολογίζουμε κάτι να το αποθηκεύουμε, ώστε αν το
ξαναχρειαστούμε να μην το ξαναυπολογίζουμε). Μην υπολογίζετε ξανά και ξανά το
άθροισμα για όλους τους δυνατούς υποπίνακες. Αν βρείτε ένα τοπικό μέγιστο (το
μέγιστο από τη θέση 0 μέχρι μία θέση i του πίνακα arr) τότε για τη θέση i + 1 το
μέγιστο θα είναι το max(τοπικό μέγιστο (i – 1) + arr[i], arr[i]).
Παρατηρήστε στον παρακάτω πίνακα ότι αν έχουμε υπολογίσει το τοπικό μέγιστο για
τη θέση arr[4] όπου το τοπικό μέγιστο είναι το 3, τότε για την επόμενη θέση του
πίνακα, την θέση arr[5], το τοπικό μέγιστο είναι max(local-max(i – 1) + arr[i], i),
δηλαδή max(3 + 2, 2) = 5.
* */
public class MiniProject06 {
    public static void main(String[] args) {

    }
}
